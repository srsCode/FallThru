plugins {
    id 'java-library'
    id 'idea'
    id 'checkstyle'
    id 'net.neoforged.gradle.userdev' version '7.0.+'
}
if (file('../.etc/srscode-MC.gradle').exists()) { apply from:'../.etc/srscode-MC.gradle' }

base.archivesName.set mod_name

java.toolchain.languageVersion = JavaLanguageVersion.of(17)

checkstyle {
    setConfig resources.text.fromUri('https://srscode.github.io/checkstyle/srsCode-NF-checkstyle-J11+.xml')
    setReportsDir layout.buildDirectory.get().dir('reports').dir('checkstyle').asFile
    setToolVersion '10.12.5'
}
tasks.withType(Checkstyle) {
    reports {
        xml.required  = false
        html.required = true
    }
}

configurations {
    srsLib {}
    implementation.extendsFrom srsLib
}

runs {
    configureEach {
        systemProperty 'forge.logging.markers', 'REGISTRIES'
        systemProperty 'forge.logging.console.level', 'debug'
        systemProperty 'mixin.debug.export', 'true'
        modSource project.sourceSets.main
        dependencies {
            runtime project.configurations.srsLib
        }
    }

    client {programArguments '--width', '1920', '--height', '1080', '--username', 'srs_dev'}

    server {programArguments '--nogui'}
}

repositories {mavenLocal()}

jarJar.enable()
dependencies {
    implementation (group:'net.neoforged', name:'neoforge', version:"${neo_version}")
    jarJar srsLib  (group:"${group}", name:"${srslib_artifact}", version:"${srslib_version_range}") {jarJar.pin(it, "${srslib_version}")}
}

tasks.withType(ProcessResources).configureEach {
    var replaceProperties = [
            mc_version          : mc_version,
            neo_version         : neo_version,
            loader_version_range: loader_version_range,
            srslib_artifact     : srslib_artifact,
            srslib_version      : srslib_version,
            srslib_version_range: srslib_version_range,
            mod_license         : mod_license,
            mod_issue_tracker   : mod_issue_tracker,
            mod_id              : mod_id,
            mod_name            : base.archivesName.get(),
            version             : version as String,
            mod_description     : mod_description,
            mod_authors         : mod_authors,
            mod_url             : mod_url,
            mod_logoFile        : mod_logoFile,
            mc_version_range    : mc_version_range,
            neo_version_range   : neo_version_range,
            pack_format         : pack_format,
    ]
    inputs.properties replaceProperties
    filesMatching(['META-INF/mods.toml', 'pack.mcmeta']) {
        expand replaceProperties + [project: project]
    }
}

tasks.withType(JavaCompile).configureEach {options.encoding = 'UTF-8'}

tasks.getByName('jar').configure {
    from 'LICENCE.txt'
    manifest.attributes([
        'Specification-Vendor'   : "${project.group}",
        'Specification-Title'    : "${base.archivesName.get()}",
        'Specification-Version'  : '1',
        'Implementation-Vendor'  : "${project.group}",
        'Implementation-Title'   : "${base.archivesName.get()}",
        'Implementation-Version' : "${project.version}",
        'Build-Timestamp'        : java.time.OffsetDateTime.now() as String
    ])
}

tasks.getByName('jarJar').configure {
    from 'LICENCE.txt'
    archiveClassifier = '' // overwrite the jar task output
}

// A task to partially clean build outputs while leaving cached artifacts alone
tasks.create('cleanOutputs', Delete).configure {cotask ->
    tasks.getByName('assemble').configure {mustRunAfter(cotask)}
    doFirst {targetFiles.each {project.logger.lifecycle "cleaning: $it.canonicalPath"}}
    delete(tasks.withType(ProcessResources).collect {it.outputs.files.files}.flatten())
    delete(tasks.withType(JavaCompile).collect {it.outputs.files.files}.flatten())
    var libs = layout.buildDirectory.get().getAsFile().toPath().resolve("libs").toFile()
    if (libs.exists()) {delete(libs.listFiles())}
}

// A task to execute a clean build
tasks.create('cleanBuild') {
    dependsOn 'cleanOutputs', 'build'
}
